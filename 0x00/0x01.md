# 移位运算
下面两题都是同一个思路，一定要深刻理解为什么要这样拆分

## a^b
普通快速幂算法
要想快速运算，我们不禁想起 (a * b) mod k = ((a mod k) * (b mod k)) mod k，把 a^b 放到这个场景下去想，要拆开成乘法，就要把b拆开成加法。我们把b采用ci * 2^i的和的形式拆开即可。这就是快速幂算法的核心思想。
```
// 1 <= a, b, p <= 10^9

int power (int a, int b, int p) {   // a ^ b mod p
    int ans = 1;
    for (;b; b >>= 1) {
        if (b & 1) (long long)ans = ans * a % p;
        a = (long long)a * a % p;
    }
    return ans;
}

// O(log b)
```

## 64位整数乘法
求 a * b mod p, 1 <= a, b, p <= 10^18
利用和快速幂算法同样的拆分思路拆开b，会得到 a * ci * 2^i (ci = 0, 1)的和的形式。和的模也等于模的和再模。
```
long long mul (long long a, long long b, long long p) {
    long long ans = 0;
    for (;b; b >>= 1) {
        if (b & 1) ans = (ans + a % p) % p;
        a = (a * 2) % p;
    }
    return ans;
}

// O(log b)
```

# 二进制状态压缩
