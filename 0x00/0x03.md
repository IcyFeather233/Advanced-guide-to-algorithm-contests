# 前缀和
## 激光炸弹
一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有目标。现在地图上有N（N <= 10^4）个目标，用整数Xi,Yi（其值在闭区间[0, 5000]之内）表示目标在地图上的位置，每个目标都有一个价值Wi。  
激光炸弹边长为R的正方形的边必须与x, y轴平行。若目标位于爆破正方形的边上，该目标不会被摧毁。求一颗炸弹最多能炸掉地图上总价值为多少的目标。  
这题可以理解为二维的前缀和。用数组A[x, y]表示位置（i, j）上所有目标的价值之和。
接下来我们求A的二维前缀和S，即：  
`S[i, j] = Σ Σ A[x, y]`  
易得如下的递推式：  
`S[i, j] = S[i - 1, j] + S[i, j - 1] - S[i - 1, j - 1] + A[i, j]`  
同理可得`Σ Σ A[x, y](一个矩形区域中的求和) = S[i, j] - S[i - R, j] - S[i, j - R] + S[i - R, j - R]`  
因此，我们只需要递推求出二位前缀和S，然后枚举边长为R的正方形的右下角坐标（i, j），即可计算出正方形内所有目标的价值之和，更新答案。取其中最大的即可。  
其实这题也是容斥原理的思想。

# 差分
对于一个给定的序列A，它的差分序列B定义为：  
`B[1] = A[1], B[i] = A[i] - A[i - 1](2 <= i <= n)`  
容易发现，前缀和和差分是一组互逆运算。  
把序列A区间[i, j]的数都加上d，其差分序列Bi加d，Bj+1减去d，其他不变。这有助于我们在很多题目中，把原序列上的区间操作转换为差分序列上的单点操作，降低求解难度。
## IncDec Sequence
给定一个长度为n的数列，每次可以选择一个区间[l, r]，使得下标在这个区间内的数都+1或者-1。  
求至少需要多少次操作才能使数列中的数都一样，并求出在保证最少次数的前提下，最终得到的序列可能有多少种。  
分析：  
让数列中的数都一样：把数列的差分都变成0  
下面的问题就简单了，把差分数列的所有项变成0，最少需要多少步。  
我们来看看差分序列，`b[1] = a[1], b[i] = a[i] - a[i - 1](2 <= i <= n)`，我们额外设一个`b[n + 1] = 0`。为什么要这样做呢，因为右边界取到n的时候改变的是n + 1。如果不设置这个`b[n + 1]`，相当于只能操作`b[i](2 <= i <= n)`，相当于只能操作到a[n - 1]。所以必须要额外加上。  
我们知道把原数列区间[l, r]+1或者-1，其实是把差分序列的l, r+1进行+1(-1)和-1(+1)。即选差分序列的两个数，一个加一个减，两个加减同样多。  
有几个特殊的边界：  
1. l = 1
2. r = n+1
有取一个边界，两个都取，两个都不取四种情况，分类讨论。而我们要做的，是把bi(2 <= i <= n)变成0，所以同时取两个端点的操作是无用功，排除。  
设b2 ~ bn中正数总和为p，负数总和为q。首先用两个端点都不取的操作尽可能消掉小的那一个，耗费min(p, q)次，然后用|p -q|次的取一个边界的操作消掉多的那一边。总共耗费`min(p, q) + |p - q| = max(p, q)`（用数轴理解这个式子）次操作。  
下面我们求得到的序列可能有多少种。得到的序列和a1即b1有关，b1的值和取左特殊边界的次数有关。左特殊边界操作的次数在0 ~ |p - q|次之间，即有|p - q| + 1种不同的可能。  
## Tallest Cow
有N头牛站成一行，两头牛可以相互看见，当且仅当他们中间的牛的身高都比它们矮。现在我们只知道其中的第P头最高且身高为H，不知道剩余N-1头牛的身高。但是，我们还知道M对关系，每队关系都指明了某两头牛Ai和Bi可以相互看见。求每头牛的身高最多是多少。  
分析：  
关系m,n出现说明m<i<n中间的数都要比min(am, an)小至少1，所以我们用数组C表示和第P头牛的差距，C[P] = 0，其他的都是负数，然后最后算的时候是C[i] + H即可。我们用D作为C的差分数组，m,n对出现时，D[m+1] - 1，D[n] + 1。操作完了之后再用D差分数组算出C，加上H输出。
```cpp
map<pair<int, int>, bool> existed;
int c[10010], d[10010];

int main() {
	int n, p, h, m;
	cin >> n >> p >> h >> m;
	for (int i = 1; i <= m; i++) {
		int a, b;
		cin >> a >> b;
		if (a > b) swap(a, b);
		if (existed[make_pair(a, b)]) continue;
		d[a+1]--;
		d[b]++;
		existed[make_pair(a, b)] = true;
	}
	for (int i = 1; i <= m ; i++) {
		c[i] = c[i - 1] + d[i];
		cout << c[i] + h << endl;
	}
}
```

